<div class="modal fade show" id="myModal" style="display:block; background-color: rgba(10,10,10,.8);" aria-modal="true" role="dialog">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title">@Title</h4>
                @if (DialogType is ModalDialogType.DeleteCancel or ModalDialogType.OkCancel or ModalDialogType.YesNoCancel)
                {
                    <button type="button" class="close" @onclick="() => ModalTryClose(ModalDialogReturnValue.Cancel)">&times;</button>
                }
            </div>
            <div class="modal-body">
                <p>@Text</p>
                @if (RequiredFieldsWarning && InputFields.Any(FieldRequiredAndNotFilled))
                {
                    <div class="modal-input-warning">
                        <p><i class="bi bi-exclamation-triangle"></i> Please fill out: 
                            @foreach (var field in InputFields.Where(FieldRequiredAndNotFilled))
                            {
                                <span>@($"-{field.Name} ")</span>
                            }
                        </p>
                    </div>
                }
                @if (InputFields?.Count() > 0)
                {
                    <div class="modal-input">
                        @foreach (var input in InputFields)
                        {
                            var fieldType = input.Type.ToString().ToLower();
                            //we are binding the oninput event to the value in our dictionary
                            <input id="@($"modal-input-field-{input.Name.ToLower()}")" 
                                   type="@fieldType" 
                                   placeholder="@input.Name" 
                                   @oninput="@((e) => { _inputFieldValues[input.Name] = e.Value;})"
                            />
                        }
                    </div>
                }
            </div>
            <div class="modal-footer">
                @switch (DialogType)
                {
                    case ModalDialogType.Ok:
                        <button type="button" class="btn btn-primary" @onclick="() => ModalTryClose(ModalDialogReturnValue.Ok)">OK</button>
                        break;
                    case ModalDialogType.OkCancel:
                        <button type="button" class="btn btn-warning" @onclick="() => ModalTryClose(ModalDialogReturnValue.Cancel)">Cancel</button>
                        <button type="button" class="btn btn-success" @onclick="() => ModalTryClose(ModalDialogReturnValue.Ok)">OK</button>
                        break;
                    case ModalDialogType.DeleteCancel:
                        <button type="button" class="btn btn-warning" @onclick="() => ModalTryClose(ModalDialogReturnValue.Cancel)">Cancel</button>
                        <button type="button" class="btn btn-danger" @onclick="() => ModalTryClose(ModalDialogReturnValue.Delete)">Delete</button>
                        break;
                    case ModalDialogType.YesNoCancel:
                        <button type="button" class="btn btn-success" @onclick="() => ModalTryClose(ModalDialogReturnValue.Yes)">Yes</button>
                        <button type="button" class="btn btn-danger" @onclick="() => ModalTryClose(ModalDialogReturnValue.No)">No</button>
                        <button type="button" class="btn btn-warning" @onclick="() => ModalTryClose(ModalDialogReturnValue.Cancel)">Cancel</button>
                        break;
                    default:
                        throw new ArgumentOutOfRangeException(nameof(DialogType));
                }
            </div>
        </div>
    </div>
</div>

@code
{
    internal enum ModalDialogInputType
    {
        //if we need more types, feel free to expand these, but please stick to the upper case versions
        //of the allowed value of the 'input' field on the html <input> tag 
        //see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input
        Text, Number, Date, Password, Email, Image, File
    }
    public class ModalDialogInputField
    {
        internal ModalDialogInputField(string name, ModalDialogInputType type, bool required = false)
        {
            Name = name;
            Type = type;
            Required = required;
        }
        //Name of the input field
        internal readonly string Name;
        //The type of input for the field
        internal readonly ModalDialogInputType Type;
        //Whether or not the field is required
        internal readonly bool Required;
    }

    public enum ModalDialogType
    {
        Ok, OkCancel, DeleteCancel, YesNoCancel
    }

    public enum ModalDialogReturnValue
    {
        Ok, Cancel, Delete, Yes, No
    }


    public ModalDialog()
    {
        _inputFieldValues = new Dictionary<string, object>();
    }
    
    [Parameter] public string Title { get; set; }
    [Parameter] public string Text { get; set; }
    [Parameter] public EventCallback<Tuple<ModalDialogReturnValue, IDictionary<string, object>?>> OnClose { get; set; }
    [Parameter] public ModalDialogType DialogType { get; set; }
    [Parameter] public IEnumerable<ModalDialogInputField>? InputFields { get; set; }
    private bool RequiredFieldsWarning { get; set; }
    
    private IDictionary<string, object> _inputFieldValues;

    private Task ModalTryClose(ModalDialogReturnValue dialogReturnValue)
    {
        IDictionary<string, object>? inputFieldValues = null;
        //if this is a positive response, we will set the inputFieldValues to the dictionary we have been keeping this whole time
        if (dialogReturnValue is ModalDialogReturnValue.Ok or ModalDialogReturnValue.Yes && InputFields != null)
        {
            //check that all required fields are set
            if (InputFields.Any(FieldRequiredAndNotFilled))
            {
                RequiredFieldsWarning = true;
                return Task.CompletedTask;
            }
            inputFieldValues = _inputFieldValues;
        }
        //we return result and optional dictionary as tuple
        return OnClose.InvokeAsync(new Tuple<ModalDialogReturnValue, 
            IDictionary<string, object>?>(dialogReturnValue, inputFieldValues));
    }

    private bool FieldRequiredAndNotFilled(ModalDialogInputField field)
    {
        return field.Required && (!_inputFieldValues.ContainsKey(field.Name) || IsDefaultValue(_inputFieldValues[field.Name]));
    }

    private bool IsDefaultValue(object inputFieldValue)
    {
        return inputFieldValue switch
        {
            string stringValue => stringValue == "",
            int intValue => intValue == 0,
            float floatValue => floatValue == 0.0f,
            _ => throw new NotImplementedException()
        };
    }


}
