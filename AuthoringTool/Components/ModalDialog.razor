@using System.Collections
<div class="modal fade show" id="myModal" style="display:block; background-color: rgba(10,10,10,.8);" aria-modal="true" role="dialog">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title">@Title</h4>
                @if (DialogType is ModalDialogType.DeleteCancel or ModalDialogType.OkCancel or ModalDialogType.YesNoCancel)
                {
                    <button type="button" class="close" @onclick="() => ModalTryClose(ModalDialogReturnValue.Cancel)">&times;</button>
                }
            </div>
            <div class="modal-body">
                <p>@Text</p>
                @if (RequiredFieldsWarning && InputFields != null && InputFields.Any(FieldRequiredAndNotFilled))
                {
                    <div class="modal-input-warning">
                        <p><i class="bi bi-exclamation-triangle"></i> Please fill out: 
                            @foreach (var field in InputFields.Where(FieldRequiredAndNotFilled))
                            {
                                <span>@($"-{field.Name} ")</span>
                            }
                        </p>
                    </div>
                }
                @if (InputFields?.Count() > 0)
                {
                    <div class="modal-input container">
                        @foreach (var input in InputFields)
                        {
                            <div class="row pb-2 align-items-center">
                                <div class="col">@input.Name</div>
                                <div class="col">
                                    @if (input is ModalDialogDropdownInputField dropdownInput)
                                    {
                                        <select @onchange="args => { if (args.Value != null) 
                                                _inputFieldValues[input.Name] = (string)args.Value; }"
                                                disabled="@(!IsUnlocked(dropdownInput.RequiredUnlockValues))">
                                            @if (!_inputFieldValues.ContainsKey(input.Name))
                                            {
                                                <option value=""></option>
                                            }
                                            @foreach (var option in dropdownInput.PossibleValues)
                                            {
                                                <option value="@option">@option</option>
                                            }
                                        </select>
                                    }
                                    else
                                    {
                                        var fieldType = input.Type.ToString().ToLower();
                                        //we are binding the oninput event to the value in our dictionary
                                        <input id="@($"modal-input-field-{input.Name.ToLower()}")"
                                               type="@fieldType"
                                               placeholder="@input.Name"
                                               @oninput="@(e => { if (e.Value != null) 
                                                             _inputFieldValues[input.Name] = (string)e.Value;  })"
                                               @onkeydown="@(e => {if (e.Code == "Enter") 
                                                               TryCloseWithPositiveResult();})"/>
                                    }
                                </div>
                            </div>
                        }
                    </div>
                }
            </div>
            <div class="modal-footer">
                @switch (DialogType)
                {
                    case ModalDialogType.Ok:
                        <button type="button" class="btn btn-primary" @onclick="() => ModalTryClose(ModalDialogReturnValue.Ok)">OK</button>
                        break;
                    case ModalDialogType.OkCancel:
                        <button type="button" class="btn btn-warning" @onclick="() => ModalTryClose(ModalDialogReturnValue.Cancel)">Cancel</button>
                        <button type="button" class="btn btn-success" @onclick="() => ModalTryClose(ModalDialogReturnValue.Ok)">OK</button>
                        break;
                    case ModalDialogType.DeleteCancel:
                        <button type="button" class="btn btn-warning" @onclick="() => ModalTryClose(ModalDialogReturnValue.Cancel)">Cancel</button>
                        <button type="button" class="btn btn-danger" @onclick="() => ModalTryClose(ModalDialogReturnValue.Delete)">Delete</button>
                        break;
                    case ModalDialogType.YesNoCancel:
                        <button type="button" class="btn btn-success" @onclick="() => ModalTryClose(ModalDialogReturnValue.Yes)">Yes</button>
                        <button type="button" class="btn btn-danger" @onclick="() => ModalTryClose(ModalDialogReturnValue.No)">No</button>
                        <button type="button" class="btn btn-warning" @onclick="() => ModalTryClose(ModalDialogReturnValue.Cancel)">Cancel</button>
                        break;
                    default:
                        throw new ArgumentOutOfRangeException(nameof(DialogType));
                }
            </div>
        </div>
    </div>
</div>

@code
{
    internal enum ModalDialogInputType
    {
        //if we need more types, feel free to expand these, but please stick to the upper case versions
        //of the allowed value of the 'input' field on the html <input> tag 
        //see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input
        //Image is useless, its just another submit button
        //For file, we have to implement an exception to use Electron.NET for the file dialog
        Text, Number, Date, Password, Email
    }
    public class ModalDialogInputField
    {
        internal ModalDialogInputField(string name, ModalDialogInputType type, bool required = false)
        {
            Name = name;
            Type = type;
            Required = required;
        }
        //Name of the input field
        internal readonly string Name;
        //The type of input for the field
        internal readonly ModalDialogInputType Type;
        //Whether or not the field is required
        internal readonly bool Required;
    }
    public class ModalDialogDropdownInputField : ModalDialogInputField
    {
        internal ModalDialogDropdownInputField(string name, IEnumerable<string> possibleValues, IDictionary<string, string>? requiredUnlockValues = null, bool required = false) : base(name, ModalDialogInputType.Text, required)
        {
            PossibleValues = possibleValues;
            RequiredUnlockValues = requiredUnlockValues;
        }
        //TODO: we need to refactor this into IDictionary<IDictionary<string,string>, IEnumerable<string>>
        internal readonly IEnumerable<string> PossibleValues;
        internal IDictionary<string, string>? RequiredUnlockValues;
        
    }

    public enum ModalDialogType
    {
        Ok, OkCancel, DeleteCancel, YesNoCancel
    }

    public enum ModalDialogReturnValue
    {
        Ok, Cancel, Delete, Yes, No
    }


    public ModalDialog()
    {
        _inputFieldValues = new Dictionary<string, string>();
    }
    
    [Parameter] public string Title { get; set; }
    [Parameter] public string Text { get; set; }
    [Parameter] public EventCallback<Tuple<ModalDialogReturnValue, IDictionary<string, string>?>> OnClose { get; set; }
    [Parameter] public ModalDialogType DialogType { get; set; }
    [Parameter] public IEnumerable<ModalDialogInputField>? InputFields { get; set; }
    private bool RequiredFieldsWarning { get; set; }
    
    private IDictionary<string, string> _inputFieldValues;

    private Task ModalTryClose(ModalDialogReturnValue dialogReturnValue)
    {
        IDictionary<string, string>? inputFieldValues = null;
        //if this is a positive response, we will set the inputFieldValues to the dictionary we have been keeping this whole time
        if (dialogReturnValue is ModalDialogReturnValue.Ok or ModalDialogReturnValue.Yes && InputFields != null)
        {
            //check that all required fields are set
            if (InputFields.Any(FieldRequiredAndNotFilled))
            {
                RequiredFieldsWarning = true;
                return Task.CompletedTask;
            }
            inputFieldValues = _inputFieldValues;
        }
        //we return result and optional dictionary as tuple
        return OnClose.InvokeAsync(new Tuple<ModalDialogReturnValue, 
            IDictionary<string, string>?>(dialogReturnValue, inputFieldValues));
    }
    
    private Task TryCloseWithPositiveResult()
    {
        return DialogType switch
        {
            ModalDialogType.Ok => ModalTryClose(ModalDialogReturnValue.Ok),
            ModalDialogType.OkCancel => ModalTryClose(ModalDialogReturnValue.Ok),
            ModalDialogType.DeleteCancel => ModalTryClose(ModalDialogReturnValue.Delete),
            ModalDialogType.YesNoCancel => ModalTryClose(ModalDialogReturnValue.Yes),
            _ => throw new ArgumentOutOfRangeException()
        };
    }

    private bool FieldRequiredAndNotFilled(ModalDialogInputField field)
    {
        return field.Required && (!_inputFieldValues.ContainsKey(field.Name) || IsDefaultValue(_inputFieldValues[field.Name]));
    }

    private bool IsDefaultValue(object inputFieldValue)
    {
        return inputFieldValue switch
        {
            string stringValue => stringValue == "",
            int intValue => intValue == 0,
            float floatValue => floatValue == 0.0f,
            _ => throw new NotImplementedException()
        };
    }

    private bool IsUnlocked(IDictionary<string, string>? requiredValues)
    {
        return requiredValues?.All(pair => _inputFieldValues.ContainsKey(pair.Key) 
                                          && _inputFieldValues[pair.Key] == pair.Value) ?? true;
    }
}
