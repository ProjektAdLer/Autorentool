@using System.Collections
@using System.Threading.Tasks
<div class="modal fade show" id="myModal" style="display:block; background-color: rgba(10,10,10,.8);" aria-modal="true" role="dialog">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title">@Title</h4>
                @if (DialogType is ModalDialogType.DeleteCancel or ModalDialogType.OkCancel or ModalDialogType.YesNoCancel)
                {
                    <button type="button" class="close" @onclick="() => ModalTryClose(ModalDialogReturnValue.Cancel)">&times;</button>
                }
            </div>
            <div class="modal-body">
                <p>@Text</p>
                @if (RequiredFieldsWarning && InputFields != null && InputFields.Any(FieldRequiredAndNotFilled))
                {
                    <div class="modal-input-warning">
                        <p><i class="bi bi-exclamation-triangle"></i> Please fill out: 
                            @foreach (var field in InputFields.Where(FieldRequiredAndNotFilled))
                            {
                                <span>@($"-{field.Name} ")</span>
                            }
                        </p>
                    </div>
                }
                @if (InputFields?.Count() > 0)
                {
                    <div class="modal-input container">
                        @foreach (var input in InputFields)
                        {
                            <div class="row pb-2 align-items-center">
                                <div class="col">@input.Name</div>
                                <div class="col">
                                    @if (input is ModalDialogDropdownInputField dropdownInput)
                                    {
                                        <select @onchange="args => { if (args.Value != null) 
                                                _inputFieldValues[input.Name] = (string)args.Value; EnsureDropdownsUpdated(); }"
                                                disabled="@(!IsUnlocked(dropdownInput))">
                                            @if (!_inputFieldValues.ContainsKey(input.Name))
                                            {
                                                <option value=""></option>
                                            }
                                            @if (IsUnlocked(dropdownInput))
                                            {
                                                @foreach (var option in dropdownInput.ValuesToChoiceMapping.First(MappingSatisfied).AvailableChoices)
                                                {
                                                    <option value="@option">@option</option>
                                                }
                                            }
                                        </select>
                                    }
                                    else
                                    {
                                        var fieldType = input.Type.ToString().ToLower();
                                        //we are binding the oninput event to the value in our dictionary
                                        <input id="@($"modal-input-field-{input.Name.ToLower()}")"
                                               type="@fieldType"
                                               placeholder="@input.Name"
                                               @oninput="@(e => { if (e.Value != null) 
                                                             _inputFieldValues[input.Name] = (string)e.Value;  })"
                                               @onkeydown="@(e => {if (e.Code == "Enter") 
                                                               TryCloseWithPositiveResult();})"/>
                                    }
                                </div>
                            </div>
                        }
                    </div>
                }
            </div>
            <div class="modal-footer">
                @switch (DialogType)
                {
                    case ModalDialogType.Ok:
                        <button type="button" class="btn btn-primary" @onclick="() => ModalTryClose(ModalDialogReturnValue.Ok)">OK</button>
                        break;
                    case ModalDialogType.OkCancel:
                        <button type="button" class="btn btn-warning" @onclick="() => ModalTryClose(ModalDialogReturnValue.Cancel)">Cancel</button>
                        <button type="button" class="btn btn-success" @onclick="() => ModalTryClose(ModalDialogReturnValue.Ok)">OK</button>
                        break;
                    case ModalDialogType.DeleteCancel:
                        <button type="button" class="btn btn-warning" @onclick="() => ModalTryClose(ModalDialogReturnValue.Cancel)">Cancel</button>
                        <button type="button" class="btn btn-danger" @onclick="() => ModalTryClose(ModalDialogReturnValue.Delete)">Delete</button>
                        break;
                    case ModalDialogType.YesNoCancel:
                        <button type="button" class="btn btn-success" @onclick="() => ModalTryClose(ModalDialogReturnValue.Yes)">Yes</button>
                        <button type="button" class="btn btn-danger" @onclick="() => ModalTryClose(ModalDialogReturnValue.No)">No</button>
                        <button type="button" class="btn btn-warning" @onclick="() => ModalTryClose(ModalDialogReturnValue.Cancel)">Cancel</button>
                        break;
                    default:
                        throw new ArgumentOutOfRangeException(nameof(DialogType));
                }
            </div>
        </div>
    </div>
</div>

@code
{
    internal enum ModalDialogInputType
    {
        //if we need more types, feel free to expand these, but please stick to the upper case versions
        //of the allowed value of the 'input' field on the html <input> tag 
        //see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input
        //Image is useless, its just another submit button
        //For file, we have to implement an exception to use Electron.NET for the file dialog
        Text, Number, Date, Password, Email
    }
    public class ModalDialogInputField
    {
        internal ModalDialogInputField(string name, ModalDialogInputType type, bool required = false)
        {
            Name = name;
            Type = type;
            Required = required;
        }
        //Name of the input field
        internal readonly string Name;
        //The type of input for the field
        internal readonly ModalDialogInputType Type;
        //Whether or not the field is required
        internal readonly bool Required;
    }
    public class ModalDialogDropdownInputField : ModalDialogInputField
    {
        internal ModalDialogDropdownInputField(string name, IEnumerable<ModalDialogDropdownInputFieldChoiceMapping> valuesToChoiceMapping, bool required = false) : base(name, ModalDialogInputType.Text, required)
        {
            ValuesToChoiceMapping = valuesToChoiceMapping;
        }
        //TODO: we need to refactor this into IDictionary<IDictionary<string,string>, IEnumerable<string>>
        internal readonly IEnumerable<ModalDialogDropdownInputFieldChoiceMapping> ValuesToChoiceMapping;
    }

    public record struct ModalDialogDropdownInputFieldChoiceMapping(IDictionary<string, string>? RequiredValues, IEnumerable<string> AvailableChoices);

    
    public enum ModalDialogType
    {
        Ok, OkCancel, DeleteCancel, YesNoCancel
    }

    public enum ModalDialogReturnValue
    {
        Ok, Cancel, Delete, Yes, No
    }


    public ModalDialog()
    {
        _inputFieldValues = new Dictionary<string, string>();
    }

    protected override void OnParametersSet()
    {
        if (InputFields == null) return;
        foreach (var dropdownInputField in InputFields.OfType<ModalDialogDropdownInputField>())
        {
            //_inputFieldValues[dropdownInputField.Name] = "";
        }
    }
    
    [Parameter] public string Title { get; set; }
    [Parameter] public string Text { get; set; }
    [Parameter] public EventCallback<Tuple<ModalDialogReturnValue, IDictionary<string, string>?>> OnClose { get; set; }
    [Parameter] public ModalDialogType DialogType { get; set; }
    [Parameter] public IEnumerable<ModalDialogInputField>? InputFields { get; set; }
    private bool RequiredFieldsWarning { get; set; }
    
    private IDictionary<string, string> _inputFieldValues;

    /// <summary>Tries to close the dialog. If all required input fields are filled, will call <see cref="OnClose"/>
    /// with the passed dialog return value and, if applicable, the input field values.</summary>
    /// <param name="dialogReturnValue">The <see cref="ModalDialogReturnValue"/> that should be passed in the call to
    /// <see cref="OnClose"/>.</param>
    /// <returns>The Task returned by <see cref="OnClose"/> if all fields are required and filled;
    /// <see cref="Task.CompletedTask"/> otherwise</returns>
    private Task ModalTryClose(ModalDialogReturnValue dialogReturnValue)
    {
        IDictionary<string, string>? inputFieldValues = null;
        //if this is a positive response, we will set the inputFieldValues to the dictionary we have been keeping this whole time
        if (dialogReturnValue is ModalDialogReturnValue.Ok or ModalDialogReturnValue.Yes && InputFields != null)
        {
            //check that all required fields are set
            if (InputFields.Any(FieldRequiredAndNotFilled))
            {
                RequiredFieldsWarning = true;
                return Task.CompletedTask;
            }
            inputFieldValues = _inputFieldValues;
        }
        //we return result and optional dictionary as tuple
        return OnClose.InvokeAsync(new Tuple<ModalDialogReturnValue, 
            IDictionary<string, string>?>(dialogReturnValue, inputFieldValues));
    }
    
    /// <summary>Tries to close the dialog with a positive result, depending on the <see cref="ModalDialogType"/>.</summary>
    /// <returns>The <see cref="Task"/> returned by <see cref="ModalTryClose"/>.</returns>
    private Task TryCloseWithPositiveResult()
    {
        return DialogType switch
        {
            ModalDialogType.Ok => ModalTryClose(ModalDialogReturnValue.Ok),
            ModalDialogType.OkCancel => ModalTryClose(ModalDialogReturnValue.Ok),
            ModalDialogType.DeleteCancel => ModalTryClose(ModalDialogReturnValue.Delete),
            ModalDialogType.YesNoCancel => ModalTryClose(ModalDialogReturnValue.Yes),
            _ => throw new ArgumentOutOfRangeException()
        };
    }
    
    /// <summary>Determines whether an input field is required and not filled with a value other than the empty
    /// string.</summary>
    /// <returns>true if the input field is required and not filled with a string other than the empty string;
    /// false otherwise.</returns>
    /// <param name="field">The <see cref="ModalDialogInputField"/> to be checked.</param>
    private bool FieldRequiredAndNotFilled(ModalDialogInputField field) => 
        field.Required && (!_inputFieldValues.ContainsKey(field.Name) || _inputFieldValues[field.Name] == "");

    /// <summary>Determines whether the dropdown input field is unlocked or not.</summary>
    /// <returns>true if the input field is unlocked, false if it isn't.</returns>
    /// <param name="requiredValues">The input field to check for.</param>
    private bool IsUnlocked(ModalDialogDropdownInputField requiredValues)
    {
        return !requiredValues.ValuesToChoiceMapping.Any() || requiredValues.ValuesToChoiceMapping.Any(MappingSatisfied);
    }

    /// <summary>Determines whether a specific choice mapping is currently satisfied, meaning that all values
    /// required for the choices to be available in the dropdown are satisfied.</summary>
    /// <returns>true if all required values are satisfied or <c>mapping.RequiredValues</c> is null; false otherwise.</returns>
    /// <param name="mapping">The <see cref="ModalDialogDropdownInputFieldChoiceMapping"/> to be checked.</param>
    private bool MappingSatisfied(ModalDialogDropdownInputFieldChoiceMapping mapping)
    {
        return mapping.RequiredValues == null || mapping.RequiredValues.All(KeyPresentAndValueEquals);
    }
    
    /// <summary>Determines whether a key-value-pair is present in <see cref="_inputFieldValues"/> and the value
    /// is equal to the desired value.</summary>
    /// <returns>true if the key is present and the value is equal to the desired value; false otherwise.</returns>
    /// <param name="keyValuePair">The <see cref="KeyValuePair"/></param>
    private bool KeyPresentAndValueEquals(KeyValuePair<string, string> keyValuePair)
    {
        var (key, value) = keyValuePair;
        return _inputFieldValues.ContainsKey(key) && _inputFieldValues[key] == value;
    }

    /// <summary>Ensures that, on change of a dropdown input field in the dialog, all other dropdowns in the dialog
    /// will be updated. This means if the current value set in the backing dictionary <see cref="_inputFieldValues"/>
    /// is not a valid choice for the dropdown anymore (because the required values in
    /// <see cref="ModalDialogDropdownInputFieldChoiceMapping"/> are not satisfied anymore), the current value will be
    /// set to the first now valid choice, which alignes with the behaviour of the html <c>select</c> element.</summary>
    private void EnsureDropdownsUpdated()
    {
        if (InputFields == null) return;
        foreach (var dropdownInputField in InputFields.OfType<ModalDialogDropdownInputField>())
        {
            var availableChoices = dropdownInputField.ValuesToChoiceMapping.First(MappingSatisfied)
                .AvailableChoices.ToArray();
            if (!_inputFieldValues.ContainsKey(dropdownInputField.Name)) return;
            if (_inputFieldValues[dropdownInputField.Name] != "" && 
                !availableChoices.Contains(_inputFieldValues[dropdownInputField.Name]))
            {
                _inputFieldValues[dropdownInputField.Name] = availableChoices.First();
            }
        }
    }
}
