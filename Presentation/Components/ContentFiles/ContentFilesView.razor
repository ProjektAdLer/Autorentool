@using Presentation.PresentationLogic.API
@using Presentation.PresentationLogic.LearningContent
@using Presentation.Components.Dialogues
@using Presentation.PresentationLogic.AuthoringToolWorkspace
@using Presentation.PresentationLogic.Mediator
@using System.Text
<MudTable Items="Items" Class="w-full grow shrink h-full flex flex-col flex-nowrap"
          Dense="true" Virtualize="true" Filter="Filter" >
    <ToolBarContent>
        <MudText Typo="Typo.h6">All imported files</MudText>
        <MudSpacer/>
        <MudTextField @bind-Value="_searchString" Immediate="true" Placeholder="Search" Adornment="Adornment.Start"
                      AdornmentIcon="@Icons.Material.Outlined.Search"/>
    </ToolBarContent>
    <HeaderContent>
        <MudTh>Delete</MudTh>
        <MudTh>
            <MudTableSortLabel InitialDirection="SortDirection.Ascending"
                               SortBy="new Func<ILearningContentViewModel, object>(x => x.Name)">
                @nameof(ILearningContentViewModel.Name)
            </MudTableSortLabel>
        </MudTh>
        <MudTh>
            <MudTableSortLabel SortBy="new Func<ILearningContentViewModel, object>(TypeSortBy)">
                @nameof(FileContentViewModel.Type)
            </MudTableSortLabel>
        </MudTh>
        <MudTh>New Element</MudTh>
        <MudTh>Preview</MudTh>
        @if (_showFilepath)
        {
            <MudTh>@nameof(FileContentViewModel.Filepath)/@nameof(LinkContentViewModel.Link)</MudTh>
        }
    </HeaderContent>
    <RowTemplate>
        <MudTd DataLabel="Delete" Class="px-1.5">
            <MudIconButton Icon="@Icons.Material.Filled.Delete" OnClick="() => Delete(context)"/>
        </MudTd>
        <MudTd DataLabel="Name" Class="px-1.5">
            <MudTooltip Text="@context.Name" Arrow="true" Placement="Placement.Right">
                <p class="w-fit max-w-[10rem] text-ellipsis overflow-hidden">@context.Name</p>
            </MudTooltip>
        </MudTd>
        <MudTd DataLabel="Type" Class="px-1.5">
            @if (context is FileContentViewModel fileContentContext)
            {
                @fileContentContext.Type
            }
            else
            {
                <span>Link</span>
            }
        </MudTd>
        <MudTd Class="px-1.5">
            <MudIconButton Icon="@Icons.Material.Filled.Create"
                           OnClick="() => NewElementWithContent(context)"/>
        </MudTd>
        <MudTd Class="px-1.5">
            <MudIconButton Icon="@Icons.Material.Filled.Preview"
                           OnClick="() => PresentationLogic.ShowLearningContentAsync(context)"/>
        </MudTd>
        @if (_showFilepath)
        {
            <MudTd DataLabel="Filepath/Link" Class="px-1.5">
                @switch (context)
                {
                    case FileContentViewModel fileContentContext:
                        @fileContentContext.Filepath
                        break;
                    case LinkContentViewModel linkContentContext:
                        @linkContentContext.Link
                        break;
                }
            </MudTd>
        }
    </RowTemplate>
    <PagerContent>
            <MudTablePager HideRowsPerPage="true" HorizontalAlignment="HorizontalAlignment.Center"/>
        <div class="max-h-40% min-h-fit shrink grow flex flex-row m-1">
            <MudSwitch Class="pl-4" @bind-Checked="_showFilepath" Color="Color.Info">Show filepath</MudSwitch>
            <MudSpacer/>
            <MudButton OnClick="OpenContentFilesFolder" Variant="Variant.Filled" Class="btn-standard ">Open folder</MudButton>
        </div>
    </PagerContent>
</MudTable>
@code {

#pragma warning disable CS8618 - injected by framework - n.stich
    [Inject]
    private IPresentationLogic PresentationLogic { get; set; }
    [Inject]
    private IDialogService DialogService { get; set; }
    [Inject]
    private IMediator Mediator { get; set; }
    [Inject]
    private IAuthoringToolWorkspaceViewModel WorkspaceViewModel { get; set; }
#pragma warning restore CS8618
    private IEnumerable<ILearningContentViewModel> Items => PresentationLogic.GetAllContent();
    
    private string? _searchString;
    private bool _showFilepath;

    private object TypeSortBy(ILearningContentViewModel content) =>
        content is FileContentViewModel fc ? fc.Type : "Link";

    private bool Filter(ILearningContentViewModel element) =>
        FilterInternal(element, _searchString);

    private bool FilterInternal(ILearningContentViewModel element, string? searchString)
    {
        if (string.IsNullOrWhiteSpace(searchString)) return true;
        var elementType = element is FileContentViewModel fileContent ? fileContent.Type : "Link";
        if (element.Name.Contains(searchString) || elementType.Contains(searchString)) return true;
        return $"{element.Name}.{elementType}".Contains(searchString);
    }

    private async Task Delete(ILearningContentViewModel item)
    {
        //present "Delete/Cancel" dialog
        var parameters = new DialogParameters
        {
            { "SubmitButtonText", "Delete" },
            { "SubmitButtonColor", Color.Error },
            { "DialogText", $"Do you really want to delete content entry {item.Name}? " +
                            $"If you delete content which an element inside a world is using, you won't be able to " +
                            $"generate that world anymore until you add it back!" },
        };
        var options = new DialogOptions 
        {
            CloseButton = true,
            CloseOnEscapeKey = true,
            DisableBackdropClick = true,
        };
        var dialog = await DialogService.ShowAsync<GenericCancellationConfirmationDialog>("Delete content", parameters, options);
        var result = await dialog.Result;

        var matches = WorkspaceViewModel.LearningWorlds.SelectMany(world => world.AllLearningElements.Where(element => element.LearningContent.Equals(item)).Select(el => (world, el)));
        if (matches.Any())
        {
            parameters = new DialogParameters
            {
                { nameof(DeleteContentInUseConfirmationDialog.ContentName), item.Name },
                { nameof(DeleteContentInUseConfirmationDialog.WorldElementInUseTuples), matches }
            };
            var warningDialog = await DialogService.ShowAsync<DeleteContentInUseConfirmationDialog>("Confirm delete", parameters, options);
            var warningResult = await warningDialog.Result;
            if (warningResult.Canceled) return;
        }
        
        //if not cancelled, delete content
        if (!result.Canceled)
            PresentationLogic.RemoveContent(item);
    }

    public async Task RerenderAsync()
    {
        await InvokeAsync(StateHasChanged);
    }

    private void OpenContentFilesFolder()
    {
        PresentationLogic.OpenContentFilesFolder();
    }

    private void NewElementWithContent(ILearningContentViewModel content)
    {
        PresentationLogic.SetSelectedLearningContentViewModel(content);
        Mediator.RequestOpenNewElementDialog();
    }

}