@using Presentation.PresentationLogic.LearningContent.AdaptivityContent.Question
@using Microsoft.Extensions.Localization
@using Presentation.Components.Adaptivity.Forms.Models
@using Presentation.Components.Forms
@using Presentation.PresentationLogic.API
@using BusinessLogic.Entities.LearningContent.Adaptivity.Question
@using AutoMapper
@using System.Diagnostics.CodeAnalysis
<BaseForm TForm="MultipleChoiceQuestionFormModel" TEntity="IMultipleChoiceQuestion" @ref="_editQuestionForm"
          OnValidSubmit="OnValidSubmit"
          SnackbarMessage=@Localizer["EditAdaptivityQuestionForm.SnackbarMessage"]
          FormDataContainer="FormDataContainer"
          CustomValidatorFunc="ValidateModel">
    <Fields>

        <div class="rounded-lg w-4/4 px-4 pb-2">
            <MudText>Title</MudText>

            <MudText Typo="Typo.caption">@Localizer["EditAdaptivityQuestionForm.Field.QuestionText.Text"]</MudText>
            <MudTextField @bind-Value="FormDataContainer.FormModel.Text"
                          For="@(() => FormModel.Text)"
                          Lines="3"
                          Variant="Variant.Outlined"
                          DebounceInterval="DebounceInterval"
                          Class="pb-4 mt-0"/>

            <MudText>###Switch for only one answer###</MudText>
        </div>

        <MudText>@Localizer["EditAdaptivityQuestionForm.Text.Choices"]</MudText>
        <div class="rounded-lg w-4/4 px-4">
            @foreach (var choice in FormDataContainer.FormModel.Choices)
            {
                <div class="inline-flex">
                    <MudCheckBox T="bool"
                                 Checked="FormDataContainer.FormModel.CorrectChoices.Contains(choice)"
                                 CheckedChanged="b => ChangeCorrectness(choice, (bool) b!)"/>
                    <MudTextField T="string" For="() => choice.Text" @bind-Value="@choice.Text"></MudTextField>
                </div>
                <br/>
            }
        </div>

        <MudText>@Localizer["EditAdaptivityQuestionForm.Text.AddChoice"]</MudText>
        <div class="rounded-lg w-4/4 px-4">

            <span class="inline-flex">
                <MudCheckBox T="bool" @bind-Checked="@_newChoiceChecked"></MudCheckBox>
                <MudTextField T="string" @bind-Value="@_newChoiceText"></MudTextField>
                <MudIconButton OnClick="AddChoice" Icon="@Icons.Material.Filled.Add"/>
            </span>
        </div>

    </Fields>
    <FooterButtons>
        <MudButton OnClick="() => { _editQuestionForm?.SubmitAsync(); }">@Localizer["EditAdaptivityQuestionForm.Button.Edit"]</MudButton>
    </FooterButtons>
</BaseForm>

@code {

    [Parameter, EditorRequired]
    public IMultipleChoiceQuestionViewModel QuestionToEdit { get; set; } = null!;

    [Inject, AllowNull] //can never be null, DI will throw exception on unresolved types
    internal IStringLocalizer<EditAdaptivityQuestionForm> Localizer { get; set; }

    [Inject, AllowNull] //can never be null, DI will throw exception on unresolved types
    internal IFormDataContainer<MultipleChoiceQuestionFormModel, IMultipleChoiceQuestion> FormDataContainer { get; set; }

    [Inject, AllowNull] //can never be null, DI will throw exception on unresolved types
    internal IPresentationLogic PresentationLogic { get; set; }

    [Inject, AllowNull]
    internal IValidationWrapper<MultipleChoiceMultipleResponseQuestion> MultipleResponseQuestionValidator { get; set; }

    [Inject, AllowNull]
    internal IValidationWrapper<MultipleChoiceSingleResponseQuestion> SingleResponseQuestionValidator { get; set; }

    [Inject, AllowNull] //can never be null, DI will throw exception on unresolved types - n.stich
    internal IMapper Mapper { get; set; }

    [CascadingParameter]
    public MudDialogInstance MudDialog { get; set; } = default!;

    [Parameter]
    public EventCallback OnSubmitted { get; set; }

    [Parameter]
    public int DebounceInterval { get; set; } = 300;


    private MultipleChoiceQuestionFormModel FormModel => FormDataContainer.FormModel;
    private BaseForm<MultipleChoiceQuestionFormModel, IMultipleChoiceQuestion>? _editQuestionForm;


    private bool _newChoiceChecked = false;
    private string _newChoiceText = "";


    protected override async Task OnParametersSetAsync()
    {
        await base.OnParametersSetAsync();
        await MapIntoContainer();
    }

    private async Task MapIntoContainer()
    {
        Mapper.Map(QuestionToEdit, FormDataContainer.FormModel);
        await InvokeAsync(StateHasChanged);
    }

    private void OnValidSubmit(MultipleChoiceQuestionFormModel model)
    {
        switch (QuestionToEdit)
        {
            case MultipleChoiceSingleResponseQuestionViewModel singleResponseQuestion:
                PresentationLogic.EditMultipleChoiceSingleResponseQuestion(singleResponseQuestion, model.Text, model.Choices, model.CorrectChoices.First(), model.ExpectedCompletionTime);
                break;
            case MultipleChoiceMultipleResponseQuestionViewModel multipleResponseQuestion:
                PresentationLogic.EditMultipleChoiceMultipleResponseQuestion(multipleResponseQuestion, model.Text, model.Choices, model.CorrectChoices, model.ExpectedCompletionTime);
                break;
            default:
                throw new ArgumentOutOfRangeException(nameof(QuestionToEdit), "Question to edit is not a valid type");
        }

        OnSubmitted.InvokeAsync();
        MudDialog.Close(DialogResult.Ok(true));
    }

    private void AddChoice()
    {
        FormDataContainer.FormModel.Choices.Add(new ChoiceViewModel(_newChoiceText));
        if (_newChoiceChecked)
        {
            FormDataContainer.FormModel.CorrectChoices.Add(FormDataContainer.FormModel.Choices.Last());
        }
        _newChoiceChecked = false;
        _newChoiceText = "";
    }

    private void ChangeCorrectness(ChoiceViewModel choice, bool b)
    {
        if (b)
        {
            FormDataContainer.FormModel.CorrectChoices.Add(choice);
        }
        else
        {
            var choiceToRemove = FormDataContainer.FormModel.CorrectChoices.FirstOrDefault(x => x.Id == choice.Id);
            if (choiceToRemove != null)
                FormDataContainer.FormModel.CorrectChoices.Remove(choiceToRemove);
        }
    }

    private Func<object, string, Task<IEnumerable<string>>> ValidateModel => (async (_, propertyName) =>
    {
        var modelEntity = FormDataContainer.GetMappedEntity();
        return modelEntity switch
        {
            MultipleChoiceSingleResponseQuestion singleResponseQuestion => await SingleResponseQuestionValidator.ValidateAsync(singleResponseQuestion, propertyName),
            MultipleChoiceMultipleResponseQuestion multipleResponseQuestion => await MultipleResponseQuestionValidator.ValidateAsync(multipleResponseQuestion, propertyName),
            _ => throw new ArgumentOutOfRangeException(nameof(modelEntity), "Model entity is not a valid type")
            };
    });

}