@typeparam T where T : notnull
@using MudBlazor.Utilities
@using System.Diagnostics.CodeAnalysis
@inherits MudBaseInput<T>
@using Microsoft.Extensions.Localization
@using Shared.Localization

<div class="flex flex-col items-center mx-4">
    @if (Error)
    {
        <MudText Class="text-formerror">@ErrorText</MudText>
    }
    <MudTable Items="@Elements" Hover="true" Breakpoint="Breakpoint.Sm" @ref="_mudTable"
              Class="@TableClasses" Outlined="true" Style="border-color: rgb(204,204,204)"
              RowClassFunc="@SelectedRowClassFunc" OnRowClick="RowClickEvent" T="@T"
              Filter="Filter" Dense="true">
        <ToolBarContent>
            <MudTextField @bind-Value="_searchString"
                          Immediate="true"
                          Placeholder="@Localizer["TableSelect.Placeholder"]"
                          Adornment="Adornment.Start"
                          AdornmentIcon="@Icons.Material.Outlined.Search"/>
        </ToolBarContent>
        <HeaderContent>
            @HeaderContent
        </HeaderContent>
        <RowTemplate>
            @RowTemplate.Invoke(context)
        </RowTemplate>
    </MudTable>     
</div>

@code {

    [Parameter, EditorRequired, AllowNull] //allow null since not providing the parameter produces a warning - n.stich
    public IEnumerable<T> Elements { get; set; }

    [Parameter, EditorRequired, AllowNull] //allow null since not providing the parameter produces a warning - n.stich
    public Func<T, IEnumerable<string>> FilterFuncSearchableStrings { get; set; }

    [Parameter, EditorRequired, AllowNull] //allow null since not providing the parameter produces a warning - n.stich
    public RenderFragment HeaderContent { get; set; }

    [Parameter, EditorRequired, AllowNull] //allow null since not providing the parameter produces a warning - n.stich
    public RenderFragment<T> RowTemplate { get; set; }

    [Inject, AllowNull] //can never be null, DI will throw exception on unresolved types - n.stich
    internal IStringLocalizerFactory LocalizerFactory { get; set; }

    private IStringLocalizer Localizer => LocalizerFactory.GetGenericLocalizer<TableSelect<T>>();
    

    private MudTable<T>? _mudTable;
    private string? _searchString;

    private string TableClasses => CssBuilder.Empty().AddClass("border-2 border-formerror rounded-lg shadow-lg", () => Error).Build();

    private void RowClickEvent(TableRowClickEventArgs<T> tableRowClickEventArgs)
    {
        if (tableRowClickEventArgs.Item != null && tableRowClickEventArgs.Item.Equals(Value))
        {
            DeselectRow();
        }
        else
        {
            SelectRow(tableRowClickEventArgs);
        }
    }

    private void DeselectRow()
    {
    // we have to suppress the nullability warning here as we specifically want to set the value to null
    // if T is a reference type, but the compiler believes that the type T is not nullable
    // The behaviour is basically set to null if T is a reference type, otherwise set to default(T),
    // that way, enums and structs are also supported
        SetValueAsync(default!);
    }

    private void SelectRow(TableRowClickEventArgs<T> tableRowClickEventArgs)
    {
        SetValueAsync(tableRowClickEventArgs.Item);
        InvokeAsync(StateHasChanged);
    }

    private string SelectedRowClassFunc(T element, int rowNumber)
    {
        return element.Equals(Value) ? "bg-adlergrey-600" : string.Empty;
    }

    private bool Filter(T element) =>
        FilterInternal(element, _searchString);

    private bool FilterInternal(T element, string? searchString) => FilterInternal(FilterFuncSearchableStrings(element), searchString);

    private bool FilterInternal(IEnumerable<string> searchableStrings, string? searchString)
    {
        return string.IsNullOrWhiteSpace(searchString) || searchableStrings.Any(str => str.ToLowerInvariant().Contains(searchString.ToLower()));
    }

}