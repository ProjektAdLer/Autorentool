@inject IMouseService MouseService
@inject ILogger<Draggable<T>> Logger;
@implements IDisposable
@using Presentation.PresentationLogic.AuthoringToolWorkspace
@using Presentation.PresentationLogic.AdvancedLearningSpaceEditor
@using System.Numerics
@using Shared
@typeparam T

<g transform="@ComputeTransformString(X, Y)" @onmousedown="OnDown" cursor="@_cursor" @onmousedown:stopPropagation="true">
    @ChildContent
</g>

@code {

    ///Code from https://github.com/AlexeyBoiko/BlazorDraggableDemo
    //get (optional) child html content as a RenderFragment
        [Parameter]
    public RenderFragment? ChildContent { get; set; }

    //fields bound to translate vector of <g> element
    //make these nullable so we can have parent set them once via Parameter X and Y


    [Parameter, EditorRequired]
    public T? LearningObject { get; set; }

    [Parameter, EditorRequired]
    public IDictionary<int, DoublePoint>? CornerPoints { get; set; }

    [Parameter]
    public double X { get; set; }

    [Parameter]
    public double Y { get; set; }

    //we need these lines for @bind-X and @bind-Y to work, even if they look like we don't use them anywhere
    [Parameter]
    public EventCallback<double> XChanged { get; set; }

    [Parameter]
    public EventCallback<double> YChanged { get; set; }

    [Parameter]
    public EventCallback<T> OnClicked { get; set; }

    [Parameter]
    public EventCallback<T> OnDoubleClicked { get; set; }

    [Parameter]
    public EventCallback<T> OnRightClicked { get; set; }

    [Parameter]
    public DraggedEventArgs<T>.DraggedEventHandler? OnDragged { get; set; }


    //cursorX and cursorY are used to remove the offset between cursor and element on move, so we only get a delta
    private double _cursorX;
    private double _cursorY;

    private bool _isDown;
    private string _cursor = "grab";
    private bool _hasMoved;

    private double _oldPositionX;
    private double _oldPositionY;

    private DateTime _lastOnDown;
    private DateTime _lastClick;

    //This is called after component has received initial parameters in SetParametersAsync
    protected override void OnInitialized()
    {
        MouseService.OnMove += OnMove;
        MouseService.OnUp += OnUpOrOut;
        MouseService.OnOut += OnUpOrOut;
        base.OnInitialized();
    }

    protected override void OnParametersSet()
    {
        if (LearningObject == null)
        {
            throw new ArgumentNullException(nameof(LearningObject));
        }
    }

    private void OnDown(MouseEventArgs e)
    {
        _lastOnDown = DateTime.Now;
        _cursorX = e.ClientX;
        _cursorY = e.ClientY;
        _isDown = true;
        _cursor = "grabbing";
        _hasMoved = false;
        _oldPositionX = X;
        _oldPositionY = Y;
    }

    private void OnUpOrOut(object? sender, MouseEventArgs e)
    {
        switch (_isDown)
        {
            case true when !_hasMoved:
            {
                switch (e.Button)
                {
                    case 0 when (DateTime.Now - _lastClick).TotalMilliseconds < 300:
                        OnDoubleClicked.InvokeAsync(LearningObject);
                        break;
                    case 0:
                        _lastClick = DateTime.Now;
                        OnClick(sender, e);
                        break;
                    case 2:
                        OnRightClicked.InvokeAsync(LearningObject);
                        break;
                }
                break;
            }
            case true when _hasMoved:
                OnDrag(sender, e);
                break;
        }
        _isDown = false;
        _cursor = "grab";
    }

    private void OnMove(object? sender, MouseEventArgs e)
    {
        if (!_isDown) return;
        X -= _cursorX - e.ClientX;
        Y -= _cursorY - e.ClientY;

        _cursorX = e.ClientX;
        _cursorY = e.ClientY;

        XChanged.InvokeAsync(X);
        YChanged.InvokeAsync(Y);

        _hasMoved = true;
    }

    private Task OnClick(object? sender, MouseEventArgs e)
    {
        Logger.LogDebug("OnClick");
    //override nullability because we check in OnParametersSet - n.stich
        Logger.LogDebug("e.OffsetX:{EOffsetX} e.OffsetY:{EOffsetY}", e.OffsetX, e.OffsetY);
        return OnClicked.InvokeAsync(LearningObject);
    }

    private void OnDrag(object? sender, MouseEventArgs e)
    {
        if (LearningObject != null) OnDragged?.Invoke(LearningObject, new DraggedEventArgs<T>(LearningObject, _oldPositionX, _oldPositionY));
    }

    public void Dispose()
    {
        MouseService.OnMove -= OnMove;
        MouseService.OnUp -= OnUpOrOut;
        MouseService.OnOut -= OnUpOrOut;
    }

    private string ComputeTransformString(double mousePointerX, double mousePointerY)
    {
        var mousePointer = new Vector2((float)mousePointerX, (float)mousePointerY);
        var closestPoint = new Vector2();
        var shortestDistance = float.MaxValue;
        var rotation = 0f;
        for (int i = 0; i < CornerPoints!.Count; i++)
        {
            var wallPoint1 = new Vector2((float)CornerPoints[i].X, (float)CornerPoints[i].Y);
            var wallPoint2 = new Vector2((float)CornerPoints[i + 1 < CornerPoints.Count ? i + 1 : 0].X, (float)CornerPoints[i + 1 < CornerPoints.Count ? i + 1 : 0].Y);
            var distance = this.ComputeDistance(mousePointer, wallPoint1, wallPoint2, out Vector2 closestLocalPoint);
            if (distance < shortestDistance)
            {
                shortestDistance = distance;
                closestPoint = closestLocalPoint;
                rotation = this.ComputeRotation(wallPoint1, wallPoint2);
            }
        }
        return "translate(" + Math.Round(closestPoint.X) + ", " + Math.Round(closestPoint.Y) + ") rotate(" + Math.Round(rotation) + ")";
    }

    private float ComputeDistance(Vector2 mousePoint, Vector2 wallPoint1, Vector2 wallPoint2, out Vector2 closestPoint)
    {
        Vector2 wallVector = wallPoint2 - wallPoint1;
        Vector2 mouseVector = mousePoint - wallPoint1;

        float wallProjection = Vector2.Dot(mouseVector, wallVector);
        float wallLength = wallVector.LengthSquared();
        float distance = wallProjection / wallLength;

        if (distance <= 0)
        {
            closestPoint = wallPoint1;
        }
        else if (distance >= 1)
        {
            closestPoint = wallPoint2;
        }
        else
        {
            closestPoint = wallPoint1 + distance * wallVector;
        }

        return Vector2.Distance(mousePoint, closestPoint);
    }

    private float ComputeRotation(Vector2 wallPoint1, Vector2 wallPoint2)
    {
        var wallVector = wallPoint2 - wallPoint1;
        var rotation = (Math.Atan2(wallVector.Y, wallVector.X) * 180 / Math.PI) -90;
        return (float)rotation;
    }
}