@page "/AuthoringToolWorkspaceView"
@using Presentation.View.World
@using Presentation.Components
@using Presentation.Components.ModalDialog
@using Presentation.PresentationLogic.API
@using Presentation.PresentationLogic.AuthoringToolWorkspace
@using Presentation.PresentationLogic.ModalDialog

<h3>AuthoringTool Workspace</h3>

<p role="status">Current count of worlds: @AuthoringToolWorkspaceVm.Worlds.Count()</p>
<p role="status" id="filepath">Filepath: @filePath</p>
<label class="world-select">
    Select world:
    <select @onchange="args => SetSelectedWorld((string) args.Value!)"
            value="@(AuthoringToolWorkspaceVm.SelectedWorld?.Name)">
        @foreach (var world in AuthoringToolWorkspaceVm.Worlds)
        {
            <option value="@world.Name">@world.Name</option>
        }
        @if (!AuthoringToolWorkspaceVm.Worlds.Any() ||
             AuthoringToolWorkspaceVm.Worlds.Count() == 1 && AuthoringToolWorkspaceVm.SelectedWorld == null)
        {
            <option value=""></option>
        }
    </select>
</label>
<div>
    <div>
        <button class="btn btn-primary" @onclick="PresentationLogic.UndoCommand" disabled="@(!PresentationLogic.CanUndo)">Undo</button>
        <button class="btn btn-primary" @onclick="PresentationLogic.RedoCommand" disabled="@(!PresentationLogic.CanRedo)">Redo</button>
    </div>
    @if (AuthoringToolWorkspaceVm.SelectedWorld != null)
    {
        <label class="world-data">
            Selected world: @AuthoringToolWorkspaceVm.SelectedWorld.Name,
            Description: @AuthoringToolWorkspaceVm.SelectedWorld.Description,
            Spaces: @AuthoringToolWorkspaceVm.SelectedWorld.Spaces.Count
        </label>
    }
</div>
<div>
    <button class="btn btn-primary add-world" @onclick="AddNewWorld">Add World</button>
    <button class="btn btn-primary load-world" @onclick="LoadWorldAsync">Load World</button>
    <button class="btn btn-primary edit-world" @onclick="OpenEditSelectedWorldDialog" disabled="@(!AuthoringToolWorkspaceP.WorldSelected)">Edit World</button>
    <button class="btn btn-primary delete-world" @onclick="DeleteSelectedWorld" disabled="@(!AuthoringToolWorkspaceP.WorldSelected)">Delete selected World</button>
    <button class="btn btn-primary save-world" @onclick="SaveSelectedWorldAsync" disabled="@(!AuthoringToolWorkspaceP.WorldSelected)">Save selected World</button>
    <button class="btn btn-primary export-world" id="btnExport" @onclick="ExportWorld">Create Export-File</button>
</div>
<DropZone OnNewStream=OnDragAndDropResult></DropZone>

@if (AuthoringToolWorkspaceP.InformationMessageToShow != null)
{
    @ModalDialogFactory.GetInformationMessageFragment(OnShowInformationDialogClose, AuthoringToolWorkspaceP.InformationMessageToShow)
}
<!-- Save dialog for shutting down -->
@if (AuthoringToolWorkspaceP.SaveUnsavedChangesDialogOpen && AuthoringToolWorkspaceP.UnsavedWorldsQueue != null
     && AuthoringToolWorkspaceP.UnsavedWorldsQueue.Any())
{
    @ModalDialogFactory.GetSaveUnsavedWorldsFragment(OnSaveWorldDialogCloseAsync, AuthoringToolWorkspaceP.UnsavedWorldsQueue.Peek().Name)
}

<!-- Save dialog for saving when deleting -->
@if (AuthoringToolWorkspaceP.DeletedUnsavedWorld != null)
{
    @ModalDialogFactory.GetDeleteUnsavedWorldFragment(OnSaveDeletedWorldDialogCloseAsync, AuthoringToolWorkspaceP.DeletedUnsavedWorld.Name)
}

@if (AuthoringToolWorkspaceP.CreateWorldDialogOpen)
{
    @ModalDialogFactory.GetCreateWorldFragment(OnCreateWorldDialogClose)
}
@if (AuthoringToolWorkspaceVm.SelectedWorld != null)
{
    <WorldView>
        </WorldView>
}

@if (AuthoringToolWorkspaceP.EditWorldDialogOpen)
{
    <!-- EditDialogInitialValues is set by presenter before setting EditWorldDialogOpen to true -->
    @ModalDialogFactory.GetEditWorldFragment(AuthoringToolWorkspaceVm.EditDialogInitialValues!, OnEditWorldDialogClose)
}

@if (ErrorState != null)
{
    @ModalDialogFactory.GetErrorStateFragment(OnExceptionEncounteredDialogClose, ErrorState.ToString())
}


@code {

#pragma warning disable CS8618 // injected by framework - m.ho
    [Inject]
    public IMouseService MouseService { get; set; }
    [Inject]
    public IAuthoringToolWorkspacePresenter AuthoringToolWorkspaceP { get; set; }
    [Inject]
    public IAuthoringToolWorkspaceViewModel AuthoringToolWorkspaceVm { get; set; }
    [Inject]
    public IPresentationLogic PresentationLogic { get; set; }
    [Inject]
    public IAuthoringToolWorkspaceViewModalDialogFactory ModalDialogFactory { get; set; }
#pragma warning restore CS8618

    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        AuthoringToolWorkspaceP.OnForceViewUpdate += async () => await InvokeAsync(StateHasChanged);
        AuthoringToolWorkspaceVm.PropertyChanged += async (_, _) => await InvokeAsync(StateHasChanged);
        PresentationLogic.OnUndoRedoPerformed += async () => await InvokeAsync(StateHasChanged);
    }
    
    private string filePath = "";

    private ExceptionWrapper? ErrorState { get; set; }

    private void AddNewWorld()
    {
        AuthoringToolWorkspaceP.AddNewWorld();
    }

    private void OpenEditSelectedWorldDialog()
    {
        AuthoringToolWorkspaceP.OpenEditSelectedWorldDialog();
    }

    private void DeleteSelectedWorld()
    {
        AuthoringToolWorkspaceP.DeleteSelectedWorld();
    }

    private async void LoadWorldAsync()
    {
        try
        {
            await AuthoringToolWorkspaceP.LoadWorldAsync();
        }
        catch (OperationCanceledException)
        {
    //nothing to do, perhaps we want to show a notification?
        }
        catch (Exception exception)
        {
            ErrorState = new ExceptionWrapper("Loading world", exception);
        }
        finally
        {
    //we need to tell blazor explicitly to re-render our component after we added the loaded world
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task SaveSelectedWorldAsync()
    {
        try
        {
            await AuthoringToolWorkspaceP.SaveSelectedWorldAsync();
        }
        catch (OperationCanceledException)
        {
    //nothing to do, perhaps we want to show a notification?
        }
        catch (Exception exception)
        {
            ErrorState = new ExceptionWrapper("Saving world", exception);
        }
        finally
        {
            await InvokeAsync(StateHasChanged);
        }
    }

    private void OnCreateWorldDialogClose(ModalDialogOnCloseResult returnValueTuple)
    {
        AuthoringToolWorkspaceP.OnCreateWorldDialogClose(returnValueTuple);
        InvokeAsync(StateHasChanged);
    }

    private void OnEditWorldDialogClose(ModalDialogOnCloseResult returnValueTuple)
    {
        AuthoringToolWorkspaceP.OnEditWorldDialogClose(returnValueTuple);
        InvokeAsync(StateHasChanged);
    }

    private void OnSaveWorldDialogCloseAsync(ModalDialogOnCloseResult returnValueTuple)
    {
        try
        {
            AuthoringToolWorkspaceP.OnSaveWorldDialogClose(returnValueTuple);
        }
        catch (Exception ex)
        {
            ErrorState = new ExceptionWrapper(nameof(OnSaveWorldDialogCloseAsync), ex);
        }
        finally
        {
            InvokeAsync(StateHasChanged);
        }
    }

    private void OnSaveDeletedWorldDialogCloseAsync(ModalDialogOnCloseResult returnValueTuple)
    {
        AuthoringToolWorkspaceP.OnSaveDeletedWorldDialogClose(returnValueTuple);
        InvokeAsync(StateHasChanged);
    }

    private void SetSelectedWorld(string argsValue)
    {
        AuthoringToolWorkspaceP.SetSelectedWorld(argsValue);
        InvokeAsync(StateHasChanged);
    }

    private async void ExportWorld()
    {
    //Create XMl-files, Overwrite Encoding to UTF-8 and Create Backup-File
        if (AuthoringToolWorkspaceVm.SelectedWorld == null) return;
        try
        {
            filePath = await PresentationLogic.ConstructBackupAsync(AuthoringToolWorkspaceVm.SelectedWorld);
        }
        catch (OperationCanceledException)
        {
    //do nothing
        }
        await InvokeAsync(StateHasChanged);
    }

    private async Task OnDragAndDropResult(Tuple<string, MemoryStream> result)
    {
        await AuthoringToolWorkspaceP.ProcessDragAndDropResult(result);
        await InvokeAsync(StateHasChanged);
    }

    private void OnShowInformationDialogClose(ModalDialogOnCloseResult result)
    {
        AuthoringToolWorkspaceP.InformationMessageToShow = null;
        InvokeAsync(StateHasChanged);
    }

    private void OnExceptionEncounteredDialogClose(ModalDialogOnCloseResult result)
    {
        ErrorState = null;
        InvokeAsync(StateHasChanged);
    }
}