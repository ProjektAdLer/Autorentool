@page "/WorldViewRedesign"
@using Presentation.PresentationLogic.ModalDialog
@using Presentation.View.Space
@using Size = MudBlazor.Size
@using Color = MudBlazor.Color
@using Presentation.Components.ModalDialog
@using System.ComponentModel
@using Presentation.PresentationLogic.AuthoringToolWorkspace
@using Presentation.PresentationLogic.PathWay
@using Presentation.PresentationLogic.Space
@using Presentation.PresentationLogic.World
@using Presentation.View.PathWay
@using Direction = Shared.Direction
@ChildContent

<div>
    <h2>World: @WorldP.WorldVm?.Name</h2>
    <h5>Workload: @WorldP.WorldVm?.Workload minutes</h5>
    <h5>Points: @WorldP.WorldVm?.Points </h5>
</div>
<div class="p-2">
    <MudButton Variant="Variant.Filled" Color="Color.Tertiary" @onclick="AddNewSpace">New Space</MudButton>
    <MudButton Variant="Variant.Filled" Color="Color.Tertiary" @onclick="AddNewPathWayCondition">New Condition</MudButton>
    <MudButton Variant="Variant.Filled" Color="Color.Tertiary" @onclick="LoadSpaceAsync">Load Space</MudButton>
</div>
<div class="p-2">
    <MudFab Size="Size.Small" Color="Color.Primary" StartIcon="@Icons.Material.Rounded.Edit" Disabled="@(WorldP.WorldVm?.SelectedObject == null || WorldP.WorldVm.SelectedObject is IPathWayViewModel)" @onclick="EditDraggableObject"></MudFab>
    <MudFab Size="Size.Small" Color="Color.Secondary" StartIcon="@Icons.Material.Rounded.Delete" Disabled="@(WorldP.WorldVm?.SelectedObject == null)" @onclick="DeleteSelectedDraggableObject"></MudFab>
    <MudFab Size="Size.Small" Color="Color.Primary" StartIcon="@Icons.Material.Rounded.Save" Disabled="@(WorldP.WorldVm?.SelectedObject == null || WorldP.WorldVm.SelectedObject is not ISpaceViewModel)" @onclick="SaveSelectedSpaceAsync"></MudFab>
</div>

<!-- <svg style="width: 400px; height: 600px; border:3px black; background-color: white" -->
<svg style="width: 600px; height: 800px; border:3px black; background-color: white"
     xmlns="http://www.w3.org/2000/svg"
     @onmousemove=@(e => MouseService.FireMove(this, e))
             @onmouseup=@(e => MouseService.FireUp(this, e))
             @onmouseleave=@(e => MouseService.FireOut(this, e))>
    @if (WorldP.WorldVm != null)
    {
        @foreach (var pathWayCondition in WorldP.WorldVm.PathWayConditions)
        {
            <DraggablePathWayCondition ObjectInPathWay="pathWayCondition"
                                       OnClickedDraggable="@WorldP.ClickOnObjectInWorld"
                                       OnDraggedDraggable="@WorldP.DragObjectInPathWay"
                                       OnClickedDeletePath="@WorldP.DeletePathWay"
                                       OnClickedDeleteObject="@WorldP.DeleteDraggableObject"
                                       OnRightClickedDraggable="@WorldP.RightClickOnObjectInPathWay"
                                       ShowingRightClickMenu="pathWayCondition == WorldP.RightClickedObject"
                                       OnEditPathWayCondition="@WorldP.EditObjectInPathWay"
                                       OnDeletePathWayCondition="@WorldP.DeletePathWayCondition"
                                       OnCloseRightClickMenu="@WorldP.HideRightClickMenu"
                                       PositioningService="@WorldP">
                <ConditionToggleSwitch ObjectInPathWay="pathWayCondition"
                                            OnSwitchPathWayCondition="@WorldP.SwitchPathWayCondition"/>
            </DraggablePathWayCondition>
        }
        
        @foreach(var space in WorldP.WorldVm.Spaces)
        {
            <DraggableSpace ObjectInPathWay="space"
                                    OnClickedDraggable="@WorldP.ClickOnObjectInWorld"
                                    OnDraggedDraggable="@WorldP.DragObjectInPathWay"
                                    OnClickedDeletePath="@WorldP.DeletePathWay"
                                    OnClickedDeleteObject="@WorldP.DeleteDraggableObject"
                                    OnDoubleClickedDraggable="@WorldP.DoubleClickOnSpaceInWorld"
                                    OnRightClickedDraggable="@WorldP.RightClickOnObjectInPathWay"
                                    ShowingRightClickMenu="space == WorldP.RightClickedObject"
                                    OnOpenSpace="@WorldP.ShowSelectedSpaceView"
                                    OnEditSpace="@WorldP.EditObjectInPathWay"
                                    OnDeleteSpace="@WorldP.DeleteSpace"
                                    OnCloseRightClickMenu="@WorldP.HideRightClickMenu"
                                    PositioningService="@WorldP"/>
        }

        @foreach (var pathWay in WorldP.WorldVm.PathWays)
        {
            <PathWay X1=@(pathWay.SourceObject.OutputConnectionX) Y1=@(pathWay.SourceObject.OutputConnectionY + 6)
                     Direction1=Direction.Right X2=@(pathWay.TargetObject.InputConnectionX)
                     Y2=@(pathWay.TargetObject.InputConnectionY) Direction2=Direction.Left
                     PathWayViewModel="pathWay" OnClickedClickable="@WorldP.ClickOnObjectInWorld"
                     PositioningService="WorldP" />
        }
    }
    <!-- The RightClickMenu might lies behind other spaces. 
    This line brings the RightClickMenu back to top, but the clickable buttons do not work anymore. -->
    <!--<use xlink:href="#rightClickMenu" />-->
</svg>

@if (WorldP.CreateSpaceDialogOpen)
    {
        //create space modal
        @ModalDialogFactory.GetCreateSpaceFragment(OnCreateSpaceDialogClose)
    }

    @if (WorldP.CreatePathWayConditionDialogOpen)
    {
        //create pathway condition modal
        @ModalDialogFactory.GetCreatePathWayConditionFragment(OnCreatePathWayConditionDialogClose)
    }

    @if (WorldP.EditSpaceDialogOpen && WorldP.WorldVm != null)
    {
        //edit space modal
        <!-- EditSpaceDialogInitialValues is set by presenter before setting EditSpaceDialogOpen to true -->
        @ModalDialogFactory.GetEditSpaceFragment(WorldP.EditSpaceDialogInitialValues!, OnEditSpaceDialogClose, WorldP.EditSpaceDialogAnnotations)
    }

    @if (WorldP.EditPathWayConditionDialogOpen && WorldP.WorldVm != null)
    {
        //edit pathway condition modal
        <!-- EditConditionDialogInitialValues is set by presenter before setting EditPathWayConditionDialogOpen to true -->
        @ModalDialogFactory.GetEditPathWayConditionFragment(WorldP.EditConditionDialogInitialValues!, OnEditPathWayConditionDialogClose)
    }

    @if (ErrorState != null)
    {
        <ModalDialog Title="Exception encountered" Text=@ErrorState.ToString()
                     OnClose="@ErrorDialogOnClose" DialogType=@ModalDialogType.Ok/>
    }

@code {
    [Parameter]
    public RenderFragment? ChildContent { get; set; }

#pragma warning disable CS8618 // injected by framework - n.stich
    [Inject]
    public IMouseService MouseService { get; set; }
    
    [Inject]
    public IWorldPresenter WorldP { get; set; }
    
    [Inject]
    public IWorldViewModalDialogFactory ModalDialogFactory { get; set; }
#pragma warning restore CS8618
    
    private ExceptionWrapper? ErrorState { get; set; }

    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        WorldP.PropertyChanging += OnWorldPresenterPropertyChanging;
        WorldP.PropertyChanged += OnWorldPresenterPropertyChanged;
        WorldP.OnUndoRedoPerformed += async () => await InvokeAsync(StateHasChanged);
    }

    private void AddNewSpace()
    {
        WorldP.AddNewSpace();
    }
    
    private void AddNewPathWayCondition()
    {
        WorldP.AddNewPathWayCondition();
    }

    private void DeleteSelectedDraggableObject()
    {
        WorldP.DeleteSelectedObject();
    }

    private async Task LoadSpaceAsync()
    {
        try
        {
            await WorldP.LoadSpaceAsync();
        }
        catch (OperationCanceledException)
        {
    //nothing to do, show notification?
        }
        catch (Exception exception)
        {
            ErrorState = new ExceptionWrapper("Load space", exception);
        }
        finally
        {
    //we need to tell blazor explicitly to re-render our component after we added the loaded space
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task SaveSelectedSpaceAsync()
    {
        try
        {
            await WorldP.SaveSelectedSpaceAsync();
        }
        catch (OperationCanceledException)
        {
    //nothing to do, show notification?
        }
        catch (Exception exception)
        {
            ErrorState = new ExceptionWrapper("Save space", exception);
        }
        finally
        {
    //we need to tell blazor explicitly to re-render our component after we added the loaded space
            await InvokeAsync(StateHasChanged);
        }
    }

    private void OnCreateSpaceDialogClose(ModalDialogOnCloseResult returnValueTuple)
    {
        WorldP.OnCreateSpaceDialogClose(returnValueTuple);
        InvokeAsync(StateHasChanged);
    }
    
    private void OnCreatePathWayConditionDialogClose(ModalDialogOnCloseResult returnValueTuple)
    {
        WorldP.OnCreatePathWayConditionDialogClose(returnValueTuple);
        InvokeAsync(StateHasChanged);
    }

    private void EditDraggableObject()
    {
        WorldP.OpenEditSelectedObjectDialog();
    }
    
    private void OnEditPathWayConditionDialogClose(ModalDialogOnCloseResult returnValueTuple)
    {
        WorldP.OnEditPathWayConditionDialogClose(returnValueTuple);
        InvokeAsync(StateHasChanged);
    }

    private void OnEditSpaceDialogClose(ModalDialogOnCloseResult returnValueTuple)
    {
        WorldP.OnEditSpaceDialogClose(returnValueTuple);
        InvokeAsync(StateHasChanged);
    }

    public void TriggerStateHasChanged()
    {
        InvokeAsync(StateHasChanged);
    }

    private void ErrorDialogOnClose(ModalDialogOnCloseResult _)
    {
        ErrorState = null;
        TriggerStateHasChanged();
    }
    
    private void OnWorldViewModelPropertyChanged(object? sender, PropertyChangedEventArgs args)
    {
        TriggerStateHasChanged();
    }

    private void OnWorldPresenterPropertyChanged(object? sender, PropertyChangedEventArgs args)
    {
        if (args.PropertyName == nameof(WorldP.WorldVm) && WorldP.WorldVm != null)
        {
            WorldP.WorldVm.PropertyChanged += OnWorldViewModelPropertyChanged;
        }
        TriggerStateHasChanged();
    }

    private void OnWorldPresenterPropertyChanging(object? sender, PropertyChangingEventArgs args)
    {
        if (args.PropertyName == nameof(WorldP.WorldVm) && WorldP.WorldVm != null)
        {
            WorldP.WorldVm.PropertyChanged -= OnWorldViewModelPropertyChanged;
        }
    }
}