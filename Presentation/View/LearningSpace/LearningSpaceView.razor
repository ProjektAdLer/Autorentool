@using Presentation.View.LearningElement
@using Presentation.Components.ModalDialog
@using Presentation.PresentationLogic.AuthoringToolWorkspace
@using Presentation.PresentationLogic.LearningSpace
@using Presentation.PresentationLogic.ModalDialog
@using System.ComponentModel
@using Shared

<h2>LearningSpace @LearningSpaceP.LearningSpaceVm?.Name</h2>
<h5>Workload: @LearningSpaceP.LearningSpaceVm?.Workload minutes</h5>
<h5>Points: @LearningSpaceP.LearningSpaceVm?.Points</h5>
<button class="btn btn-primary add-learning-element" @onclick="AddNewLearningElement">Add Learning Element</button>
<button class="btn btn-primary load-learning-element" @onclick="LoadLearningElementAsync">Load Learning Element</button>
<h1>Anzahl Lernelemente: @LearningSpaceP.LearningSpaceVm?.LearningSpaceLayout.Count</h1>
@ChildContent
<br>

@if (LearningSpaceP.LearningSpaceVm?.SelectedLearningElement != null)
{
    <label id="learning-element-info">
        Selected element: 
        @LearningSpaceP.LearningSpaceVm.SelectedLearningElement.Name, 
        Description: @LearningSpaceP.LearningSpaceVm.SelectedLearningElement.Description
    </label>
    <br>
    <button class="btn btn-primary edit-learning-element" @onclick="EditSelectedLearningElement">Edit selected Learning Element</button>
    <button class="btn btn-primary delete-learning-element" @onclick="DeleteSelectedLearningElement">Delete Learning Element</button>
    <button class="btn btn-primary save-learning-element" @onclick="SaveSelectedLearningElementAsync">Save selected Learning Element</button>
    <button class="btn btn-primary show-element-content" @onclick="ShowSelectedElementContentAsync">Show content of Learning Element</button>
}
<br>
Select learning world:
    <select @onchange="args => SetLearningSpaceLayout(args.Value!.ToString())"
            value="@(LearningSpaceP.LearningSpaceVm?.LearningSpaceLayout.FloorPlanName)">
        @foreach (var floorPlan in Enum.GetValues(typeof(FloorPlanEnum)).Cast<FloorPlanEnum>())
        {
            <option value="@floorPlan">@floorPlan.ToString()</option>
        }
    </select>
@if (LearningSpaceP.LearningSpaceVm != null)
{
    <div style="width: 200px; height: 200px; border: 2px solid orange;"></div>
    @for (var i = 0; i<LearningSpaceP.LearningSpaceVm.LearningSpaceLayout.Capacity;  i++)
    {
        var x = i;
        if (LearningSpaceP.LearningSpaceVm.LearningSpaceLayout.GetElement(i) != null)
        {
            <MudButton
                Variant="Variant.Filled" Color="Color.Secondary"
                @onclick="() => EditLearningElement(x)">
                @x @LearningSpaceP.LearningSpaceVm.LearningSpaceLayout.GetElement(x)?.Name
            </MudButton>
        }
        else
        {
            <MudButton
                Variant="Variant.Filled" Color="Color.Tertiary"
                @onclick="() => AddNewLearningElement(x)">
                Slot @x
            </MudButton>
        }
    }
}

<svg style="width: 100%; height: 600px; border: 1px solid green"
     xmlns="http://www.w3.org/2000/svg"
     @onmousemove="@(e => MouseService.FireMove(this, e))"
     @onmouseup="@(e => MouseService.FireUp(this, e))"
     @onmouseleave="@(e => MouseService.FireOut(this, e))"
     @onmousedown="@LearningSpaceP.HideRightClickMenu">
    @if (LearningSpaceP.LearningSpaceVm != null)
    {
        @foreach (var learningElement in LearningSpaceP.LearningSpaceVm.ContainedLearningElements)
        {
            <DraggableLearningElement LearningElement="@learningElement" 
                                      OnClicked="@LearningSpaceP.ClickedLearningElement"
                                      OnDragged="@LearningSpaceP.DragLearningElement"
                                      OnRightClicked="@LearningSpaceP.RightClickedLearningElement"
                                      OnEditLearningElement="@LearningSpaceP.EditLearningElement"
                                      OnDeleteLearningElement="@LearningSpaceP.DeleteLearningElement"
                                      OnShowLearningElementContent="@LearningSpaceP.ShowElementContent"
                                      OnCloseRightClickMenu="@LearningSpaceP.HideRightClickMenu"
                                      ShowingRightClickMenu="learningElement == LearningSpaceP.RightClickedLearningObject"/>
        }
    }
</svg>
@if (LearningSpaceP.EditLearningSpaceDialogOpen && LearningSpaceP.LearningSpaceVm != null)
{
    @ModalDialogFactory.GetEditLearningSpaceFragment(
        LearningSpaceP.EditLearningSpaceDialogInitialValues 
        ?? throw new InvalidOperationException("LearningSpacePresenter.EditLearningSpaceDialogInitialValues unexpectedly null"),
        OnEditSpaceDialogClose)
}

@if (LearningSpaceP.CreateLearningElementDialogOpen)
{
    //Override nullability because LearningSpaceVm can't be null at this point. - m.ho, n.stich
    @ModalDialogFactory.GetCreateLearningElementFragment(LearningSpaceP.DragAndDropLearningContent, OnCreateElementDialogClose)
}

@if (LearningSpaceP.EditLearningElementDialogOpen && LearningSpaceP.LearningSpaceVm != null)
{
    @ModalDialogFactory.GetEditLearningElementFragment(
        LearningSpaceP.EditLearningElementDialogInitialValues
        ?? throw new InvalidOperationException("LearningSpacePresenter.EditLearningSpaceDialogInitialValues unexpectedly null"),
        OnEditElementDialogClose)
}


@code {
#pragma warning disable CS8618 // injected by framework - n.stich
    [Inject]
    public IMouseService MouseService { get; set; }
    [Inject]
    public ILearningSpacePresenter LearningSpaceP { get; set; }
    [Inject]
    public ILearningSpaceViewModalDialogFactory ModalDialogFactory { get; set; }
#pragma warning restore CS8618

    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    
    //TODO: Instead of setting a value here we need some sort of central service that we can notify about the error to
    //then display it in the UI - n.stich
    internal ExceptionWrapper? ErrorState { get; private set; }
    
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        LearningSpaceP.OnUndoRedoPerformed += async () => await InvokeAsync(StateHasChanged);
        LearningSpaceP.PropertyChanged += (sender, earg) =>
        {
            if(earg.PropertyName == nameof(LearningSpaceP.CreateLearningElementDialogOpen)) InvokeAsync(StateHasChanged);
        };
    }
    
    private void AddNewLearningElement(int slotIndex)
    {
        LearningSpaceP.AddNewLearningElement(slotIndex);
    }

    private void AddNewLearningElement()
    {
        LearningSpaceP.AddNewLearningElement();
    }

    private void DeleteSelectedLearningElement()
    {
        LearningSpaceP.DeleteSelectedLearningElement();
    }

    private async Task LoadLearningElementAsync(){
        //TODO: Remove parameterless method and use the one with the parameter - AW
        try
        {
            await LoadLearningElementAsync(0);
        }
        catch (Exception e)
        {
            ErrorState = new ExceptionWrapper("", e);
        }
    }

    private async Task LoadLearningElementAsync(int slotIndex)
    {
        try
        {
            await LearningSpaceP.LoadLearningElementAsync(slotIndex);
        }
        catch (OperationCanceledException)
        {
    //nothing to do, show notification?
        }
        catch (Exception exception)
        {
            ErrorState = new ExceptionWrapper("Load learning element", exception);
        }
        finally
        {
    //we need to tell blazor explicitly to re-render our component after we added the loaded learning element
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task SaveSelectedLearningElementAsync()
    {
        try
        {
            await LearningSpaceP.SaveSelectedLearningElementAsync();
        }
        catch (OperationCanceledException)
        {
    //nothing to do, show notification?
        }
        catch (Exception exception)
        {
            ErrorState = new ExceptionWrapper("Save learning element", exception);
        }
        finally
        {
    //we need to tell blazor explicitly to re-render our component after we added the loaded learning element
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task ShowSelectedElementContentAsync()
    {
        try
        {
            await LearningSpaceP.ShowSelectedElementContentAsync();
        }
        catch (OperationCanceledException)
        {
        }
        catch (Exception exception)
        {
            ErrorState = new ExceptionWrapper("Show learning element content", exception);
        }
        finally
        {
            await InvokeAsync(StateHasChanged);
        }
    }

    private void OnCreateElementDialogClose(ModalDialogOnCloseResult closeResult)
    {
        LearningSpaceP.OnCreateElementDialogClose(closeResult);
        InvokeAsync(StateHasChanged);
    }
    
    private void EditLearningElement(int slotIndex){
        LearningSpaceP.EditLearningElement(slotIndex);
    }

    private void EditSelectedLearningElement()
    {
        LearningSpaceP.EditSelectedLearningElement();
    }

    private void OnEditSpaceDialogClose(ModalDialogOnCloseResult closeResult)
    {
        LearningSpaceP.OnEditSpaceDialogClose(closeResult);
        InvokeAsync(StateHasChanged);
    }

    private void OnEditElementDialogClose(ModalDialogOnCloseResult closeResult)
    {
        LearningSpaceP.OnEditElementDialogClose(closeResult);
        InvokeAsync(StateHasChanged);
    }

    private void SetLearningSpaceLayout(string floorPlanName)
    {
        Enum.TryParse(floorPlanName, out FloorPlanEnum floorPlan);
        LearningSpaceP.SetLearningSpaceLayout(floorPlan);
        InvokeAsync(StateHasChanged);
    }

}