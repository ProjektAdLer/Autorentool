@using Presentation.PresentationLogic.AuthoringToolWorkspace
@using Presentation.PresentationLogic.LearningElement
@using Presentation.PresentationLogic.LearningSpace
@using Presentation.PresentationLogic.LearningSpace.SpaceLayout.FloorPlans
@using Presentation.View.LearningElement
@using Shared
@using System.Text

<h2>LearningSpace @LearningSpaceP.LearningSpaceVm?.Name</h2>
<h5>Workload: @LearningSpaceP.LearningSpaceVm?.Workload minutes</h5>
<h5>Points: @LearningSpaceP.LearningSpaceVm?.Points</h5>
<button class="btn btn-primary load-learning-element" @onclick="LoadLearningElementAsync">Load Learning Element</button>
<h1>Anzahl Lernelemente: @LearningSpaceP.LearningSpaceVm?.LearningSpaceLayout.Count</h1>
@ChildContent
<br>

<MudDropZone T="ILearningElementViewModel" Identifier="unplacedElements"
             Class="rounded-lg border-2 border-solid mud-border-lines-default p-6 m-8 w-28 min-h-1 flex justify-center items-center flex-col">
    <ItemRenderer>
        @{
            var item = context;
            var text = item.Name + " " + item.Parent?.Name;
        }
        <MudListItem Text="@text"></MudListItem>

    </ItemRenderer>
</MudDropZone>

@if (LearningSpaceP.LearningSpaceVm != null)
{
    @if (LearningSpaceP.LearningSpaceVm?.SelectedLearningElement != null)
    {
        <label id="learning-element-info">
            Selected element:
            @LearningSpaceP.LearningSpaceVm.SelectedLearningElement.Name,
            Description: @LearningSpaceP.LearningSpaceVm.SelectedLearningElement.Description
        </label>
        <br>
        <button class="btn btn-primary delete-learning-element" @onclick="DeleteSelectedLearningElement">Delete Learning Element</button>
        <button class="btn btn-primary save-learning-element" @onclick="SaveSelectedLearningElementAsync">Save selected Learning Element</button>
        <button class="btn btn-primary show-element-content" @onclick="ShowSelectedElementContentAsync">Show content of Learning Element</button>
    }
        <br>
        <p>Select learning world:</p>
        <select @onchange="args => SetLearningSpaceLayout(args.Value!.ToString())"
                value="@(LearningSpaceP.LearningSpaceVm?.LearningSpaceLayout.FloorPlanName)">
            @foreach (var floorPlan in Enum.GetValues(typeof(FloorPlanEnum)).Cast<FloorPlanEnum>())
            {
                <option value="@floorPlan">@floorPlan.ToString()</option>
            }
        </select>
    @if (LearningSpaceP.LearningSpaceVm != null)
    {
        <div style="width: 600px; height: 400px; border: 2px solid orange;">
            <div class="layout-shadow">
                <div class="layout" style="@GetCornerPointsString(LearningSpaceP.LearningSpaceVm.LearningSpaceLayout.FloorPlanViewModel) width: 600px; height: 400px; position: relative;">

                    @for (var i = 0; i < LearningSpaceP.LearningSpaceVm.LearningSpaceLayout.Capacity; i++)
                    {
                        var x = i;
                        var identifier = LearningSpaceP.LearningSpaceVm.Id.ToString() + x;

                        <MudDropZone T="ILearningElementViewModel" Identifier="@identifier"
                                     Class="rounded-lg border-2 border-solid mud-border-lines-default p-6 m-8 w-28 h-3 flex justify-center items-center"
                                     style="@GetSlotPositionString(LearningSpaceP.LearningSpaceVm.LearningSpaceLayout.FloorPlanViewModel, x)"
                                     @onclick="() => AddNewLearningElement(x)">
                            <ItemRenderer>
                                <DragDropLearningElement
                                    LearningElement="@context"
                                    OnShowLearningElementContent="@LearningSpaceP.ShowElementContent"
                                    OnEditLearningElement="@LearningSpaceP.EditLearningElement"
                                    OnDeleteLearningElement="@LearningSpaceP.DeleteLearningElement"
                                    OnClicked="@LearningSpaceP.ClickedLearningElement"/>
                            </ItemRenderer>
                        </MudDropZone>
                    }

                </div>
            </div>
        </div>
    }
}

@code {
#pragma warning disable CS8618 // injected by framework - n.stich
    [Inject]
    public ILearningSpacePresenter LearningSpaceP { get; set; }
#pragma warning restore CS8618

    [Parameter]
    public RenderFragment? ChildContent { get; set; }

    //TODO: Instead of setting a value here we need some sort of central service that we can notify about the error to
    //then display it in the UI - n.stich
    internal ExceptionWrapper? ErrorState { get; private set; }

    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        LearningSpaceP.OnUndoRedoPerformed += async () => await InvokeAsync(StateHasChanged);
    }

    private void DeleteSelectedLearningElement()
    {
        LearningSpaceP.DeleteSelectedLearningElement();
    }

    private async Task LoadLearningElementAsync()
    {
    //TODO: Remove parameterless method and use the one with the parameter - AW
        try
        {
            await LoadLearningElementAsync(0);
        }
        catch (Exception e)
        {
            ErrorState = new ExceptionWrapper("", e);
        }
    }

    private async Task LoadLearningElementAsync(int slotIndex)
    {
        try
        {
            await LearningSpaceP.LoadLearningElementAsync(slotIndex);
        }
        catch (OperationCanceledException)
        {
    //nothing to do, show notification?
        }
        catch (Exception exception)
        {
            ErrorState = new ExceptionWrapper("Load learning element", exception);
        }
        finally
        {
    //we need to tell blazor explicitly to re-render our component after we added the loaded learning element
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task SaveSelectedLearningElementAsync()
    {
        try
        {
            await LearningSpaceP.SaveSelectedLearningElementAsync();
        }
        catch (OperationCanceledException)
        {
    //nothing to do, show notification?
        }
        catch (Exception exception)
        {
            ErrorState = new ExceptionWrapper("Save learning element", exception);
        }
        finally
        {
    //we need to tell blazor explicitly to re-render our component after we added the loaded learning element
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task ShowSelectedElementContentAsync()
    {
        try
        {
            await LearningSpaceP.ShowSelectedElementContentAsync();
        }
        catch (OperationCanceledException)
        {
        }
        catch (Exception exception)
        {
            ErrorState = new ExceptionWrapper("Show learning element content", exception);
        }
        finally
        {
            await InvokeAsync(StateHasChanged);
        }
    }

    private void EditLearningElement(int slotIndex)
    {
        LearningSpaceP.EditLearningElement(slotIndex);
    }

    private void SetLearningSpaceLayout(string floorPlanName)
    {
        Enum.TryParse(floorPlanName, out FloorPlanEnum floorPlan);
        LearningSpaceP.SetLearningSpaceLayout(floorPlan);
        InvokeAsync(StateHasChanged);
    }

    private Task RightClickedDropItem(MouseEventArgs mouseEventArgs, ILearningElementViewModel item)
    {
        LearningSpaceP.RightClickedLearningElement(item);
        return Task.CompletedTask;
    }

    private Task DeleteRightClickedLearningElement(ILearningElementViewModel item)
    {
        LearningSpaceP.DeleteLearningElement(item);
        return Task.CompletedTask;
    }

    private Task EditRightClickedLearningElement(ILearningElementViewModel item)
    {
        LearningSpaceP.EditLearningElement(item);
        return Task.CompletedTask;
    }

    private string GetCornerPointsString(IFloorPlanViewModel floorPlan)
    {
        var cornerPointsString = new StringBuilder();
        cornerPointsString.Append("clip-path: polygon(");
        foreach (var cornerPoint in floorPlan.CornerPoints)
        {
            cornerPointsString.Append($"{cornerPoint.X}% {cornerPoint.Y}%, ");
        }
        if (floorPlan.CornerPoints.Any())
        {
            cornerPointsString.Length -= 2;
        }
        else
        {
            cornerPointsString.Append("0% 0%");
        }
        cornerPointsString.Append(");");
        return cornerPointsString.ToString();
    }

    private String GetSlotPositionString(IFloorPlanViewModel floorPlanViewModel, int position)
    {
        var slotPosition = floorPlanViewModel.ElementSlotPositions[position];
        var slotPositionString = new StringBuilder();
        slotPositionString.Append("position: absolute; ");
        slotPositionString.Append($"top: {slotPosition.Y}%; ");
        slotPositionString.Append($"left: {slotPosition.X}%; ");
        slotPositionString.Append("transform: translate(-50%, -50%);");
        return slotPositionString.ToString();
    }

    private Task AddNewLearningElement(int i)
    {
        throw new NotImplementedException("NYI - implement after learning element dialog is implemented - n.stich");
    }

}